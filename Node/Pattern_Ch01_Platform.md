
# HOW Node.js works

## How Node.js works  

Node.js가 내부적으로 작동하는 방식을 이해하고 Node.js의 비동기 특성의 핵심 인 리액터 패턴을 소개

단일 스레드 아키텍처 및 비 차단 I / O와 같은 패턴이면의 주요 개념


## I/O is slow Blocking 

 I / O는 일반적으로 CPU 측면에서 비싸지 않지만 요청이 장치로 전송되는 순간과 작업이 완료되는 순간 사이에 지연 추가

// 소켓에 대해 수행되는 일반적인 차단 스레드
 > data = socket.read()  
// data is available   
print(data)




## I/O Non-blocking 

이 작동 모드에서 시스템 호출은 항상 데이터를 읽거나 쓸 때까지 기다리지 않고 즉시 반환. 
호출 시점에 사용할 수있는 결과가 없으면 함수는 단순히 미리 정의 된 상수를 반환하여 해당 시점에 반환 할 수있는 데이터가 없음을 나타냄.

이러한 유형의 비 차단 I / O를 처리하는 가장 기본적인 패턴은 실제 데이터가 반환 될 때까지 루프 내에서 리소스를 적극적으로 폴링하는 것

> resources = [socketA, socketB, fileA]   
while (!resources.isEmpty()) {   
  for (resource of resources) {   
    // try to read   
    data = resource.read()   
    if (data === NO_DATA_AVAILABLE) {   
      // 이 시점에서 읽을 데이터없음   
      continue    
    }  
    if (data === RESOURCE_CLOSED) {  
      // 리소스가 닫혔으므로 목록에서 제거   
      resources.remove(i)  
    } else {  
      // 일부 데이터가 입력되었으므로 프로세스 
      consumeData(data)  
    }  
  }
}
루프는 대부분의 경우 사용할 수없는 리소스를 반복하는 데 귀중한 CPU 만 소비



## I/O Event demultiplexing 

Busy-waiting은 확실히 non-blocking 리소스를 처리하는 데 이상적인 기술은 아니지만 다행히도 대부분의 최신 운영 체제는 동시 non-blocking 리소스를 효율적으로 처리 할 수있는 네이티브 메커니즘을 제공.

멀티플렉싱: 다중 신호는 제한된 용량의 매체를 통해 쉽게 전송할 수 있도록 여러 신호를 하나로 결합하는 방법

Demultiplexing: 신호가 원래 구성 요소로 다시 분할되는 반대 동작을 의미. 두 용어는 다른 영역 (예 : 비디오 처리)에서 다른 것을 하나로 결합하는 일반적인 작업을 설명하기 위해 사용되며 그 반대의 경우도 마찬가지. 

동기식 이벤트 디멀티플렉서는 여러 리소스를 감시하고 해당 리소스 중 하나에 대해 실행 된 읽기 또는 쓰기 작업이 완료되면 새 이벤트 (또는 이벤트 집합)를 반환.

동기식 이벤트 디멀티플렉서가 물론 동기식이므로 처리 할 새 이벤트가 있을 때까지 차단된다

```javascript
watchedList.add(socketA, FOR_READ)    // 리소스는 데이터 구조에 추가되어 각 리소스를 특정 작업 (이 예에서는 읽기)과 연결   
watchedList.add(fileB, FOR_READ)   
while (events = demultiplexer.watch(watchedList)) {           // 감시 할 리소스 그룹으로 설정.   demultiplexer.watch () 호출은 동기식이며 감시 된 리소스를 읽을 준비가 될 때까지 차단. 이 경우 이벤트 디멀티플렉서가 호출에서 반환되고 새로운 이벤트 집합을 처리 할 수 ​​있다.   
  // event loop  

  for (event of events) {       // 이벤트 디멀티플렉서에서 반환된 각 이벤트가 처리. 이 시점에서 각 이벤트와 관련된 리소스는 읽을 준비가 되어 있고 작업 중에 차단되지 않는다. 모든 이벤트가 처리되면 새 이벤트를 다시 처리 할 수 있을 때까지 이벤트 디멀티플렉서에서 흐름이 다시 차단.   
    // This read will never block and will always return data  
    data = event.resource.read()   
    if (data === RESOURCE_CLOSED) {   
      // the resource was closed, remove it from the watched list   
      demultiplexer.unwatch(event.resource)    
    } else {    
      // some actual data was received, process it   
      consumeData(data)   
    }
  }
}
```



이 패턴을 사용하면 바쁜 대기 기술을 사용하지 않고도 단일 스레드 내에서 여러 I / O 작업을 처리 할 수 ​​있다.  
단일 스레드를 사용하여 여러 리소스를 처리 할 수 ​​있다. 

작업은 여러 스레드에 분산되는 대신 시간에 따라 분산

단일 스레드를 갖는 것은 프로그래머가 일반적으로 동시성에 접근하는 방식에 유익한 영향




## The reactor pattern Libuv, the I/O engine of Node.js 

리액터 패턴의 기본 아이디어는 각 I / O 작업과 관련된 핸들러를 갖는 것.

Node.js의 핸들러는 콜백 (또는 줄여서 cb) 함수로 표현

핸들러는 이벤트가 생성되고 이벤트 루프에 의해 처리되는 즉시 호출

1) 애플리케이션은 이벤트 디멀티플렉서에 요청을 제출하여 새로운 I / O 작업을 생성. 응용 프로그램은 작업이 완료 될 때 호출되는 핸들러도 지정. 이벤트 디멀티플렉서에 새 요청을 제출하는 것은 비 차단 호출이며 즉시 애플리케이션에 제어권을 반환.  
2) 일련의 I / O 작업이 완료되면 이벤트 디멀티플렉서가 해당 이벤트 세트를 이벤트 대기열로 푸시.  
3) 이 시점에서 이벤트 루프는 이벤트 대기열의 항목을 반복.  
4) 각 이벤트에 대해 연관된 핸들러가 호출됩니다.    
5) 애플리케이션 코드의 일부인 핸들러는 실행이 완료되면 이벤트 루프에 대한 제어를 다시 제공 (5a). 핸들러가 실행되는 동안 새 비동기 작업 (5b)을 요청하여 새 항목이 이벤트 디멀티플렉서 (1)에 추가되도록 할 수 있다.
6) 이벤트 대기열의 모든 항목이 처리되면 이벤트 루프가 이벤트 디멀티플렉서에서 다시 차단 된 다음 새 이벤트를 사용할 수 있을 때 다른 주기를 트리거.  

응용 프로그램은 한 시점에서 (차단없이) 리소스에 액세스하는 데 관심을 표명하고 처리기를 제공.    
작업이 완료되면 다른 시점에서 호출.   
Node.js 애플리케이션은 이벤트 디멀티플렉서에 더 이상 보류중인 작업이 없고 이벤트 큐 내에서 처리 할 이벤트가 더 이상 없을 때 종료. 

리액터 패턴은 관찰 된 리소스 집합에서 새 이벤트를 사용할 수있을 때까지 차단하여 I / O를 처리 한 다음 각 이벤트를 연결된 핸들러에 전달하여 반응. 

## The recipe for Node.js

리액터 패턴과 libuv는 Node.js의 기본 빌딩 블록이지만 전체 플랫폼을 빌드하려면 세 가지 구성요소가 더 필요.     
* libuv 및 기타 저수준 기능을 자바스크립트에 래핑하고 노출하는 바인딩 세트. 
* V8은 원래 Google에서 Chrome 브라우저용으로 개발한 JavaScript 엔진. 이것이 Node.js가 매우 빠르고 효율적인 이유 중 하나. V8은 혁신적인 디자인, 속도 및 효율적인 메모리 관리로 높은 평가를 받고 있습니다. 
* 고급 Node.js API를 구현하는 핵심 JavaScript 라이브러리



# JavaScript in Node.js  


가장 명백한 차이점: Node.js에는 DOM이 없고 창이나 문서가 없다
반면 Node.js는 브라우저에서 사용할 수 없는 기본 운영체제에서 제공하는 서비스 세트에 액세스 할 수 있다. 

브라우저는 운영 체제 리소스에 대해 더 높은 수준의 추상화를 제공하므로 브라우저에서 실행되는 코드를 더 쉽게 제어하고 포함 할 수 있으므로 필연적으로 기능이 제한. 
결과적으로 Node.js에서는 운영 체제에서 제공하는 모든 서비스에 가상으로 액세스 할 수 있다.


## Run the latest JavaScript with confidence 

브라우저에서 JavaScript를 사용할 때의 주요 문제점 중 하나는 코드가 다양한 장치와 브라우저에서 실행될 가능성이 있다는 것. 다른 브라우저를 다루는 것은 언어 또는 웹 플랫폼의 최신 기능 중 일부를 놓칠 수있는 JavaScript 런타임을 처리하는 것을 의미. 다행히 오늘날이 문제는 transpilers and polyfills.을 사용하여 다소 완화. 

실제로 Node.js 애플리케이션은 이미 잘 알려진 시스템 및 Node.js 런타임에서 실행될 가능성이 높다. 이는 특정 JavaScript 및 Node.js 버전에 대한 코드를 대상으로 삼을 수 있기 때문에 큰 차이. 

이 요소는 Node.js가 V8의 최신 버전과 함께 제공된다는 사실과 결합하여 최신 ECMAScript 사양 (줄여서 ES)의 대부분의 기능을 안심하고 사용할 수 있음을 의미. 
이는 JavaScript 언어의 표준. 기반) 추가 변환 단계가 필요하지 않다. 

일반적인 패턴은 가장 오래된 활성 LTS (장기 지원) 릴리스를 대상으로하고 package.json에서 engines 섹션을 지정하여 패키지 관리자가 다음과 같은 패키지를 설치하려는 경우 사용자에게 경고하도록 하는 것. 




## The module system 

처음부터 Node.js는 JavaScript가 어떤 형태로든 공식적으로 지원하지 않는 경우에도 모듈 시스템과 함께 제공. 

원래 Node.js 모듈 시스템은 CommonJS라고하며, require 키워드를 사용하여 내장 모듈 또는 장치의 파일 시스템에있는 다른 모듈에서 내 보낸 함수, 변수 및 클래스를 가져온다.    
CommonJS는 모듈 번 들러 (예 : Webpack 또는 Rollup)와 함께 사용되어 쉽게 실행 가능한 코드 번들을 생성.  
CommonJS는 개발자가 다른 서버 측 플랫폼과 동등하게 크고 잘 구성된 애플리케이션을 만들 수 있도록 Node.js에 필요한 구성 요소.   
오늘날 JavaScript에는 기본 구현이 브라우저의 구현과 다소 다르기 때문에 Node.js가 구문 만 상속하는 소위 ES 모듈 구문 (가져 오기 키워드가 더 친숙 할 수 있음)이 있다. 
실제로 브라우저는 주로 원격 모듈을 처리하지만 Node.js는 적어도 현재로서는 로컬 파일 시스템에있는 모듈만 처리 할 수 ​​있다.



## Full access to operating system services 
	
Node.js가 JavaScript를 사용하더라도 브라우저의 경계 내에서 실행되지 않음. Node.js는 기본 운영 체제에서 제공하는 모든 주요 서비스에 대한 바인딩을 가질 수 있다: 예를 들어, fs 모듈 덕분에 파일 시스템의 모든 파일에 액세스 (운영 체제 수준 권한에 따라 다름).    
또는 net 및 dgram 모듈 덕분에 저수준 TCP 또는 UDP 소켓을 사용하는 응용 프로그램을 작성할 수 있다. HTTP(S) 서버(http 및 https 모듈 사용)를 만들거나 OpenSSL의 표준 암호화 및 해싱 알고리즘(암호화 모듈 사용)을 사용할 수 있다.    
또한 일부 V8 내부 (v8 모듈)에 액세스하거나 다른 V8 컨텍스트 (vm 모듈 사용)에서 코드를 실행할 수 있다. 또한 다른 프로세스(child_process 모듈 사용)를 실행하거나 프로세스 전역 변수를 사용하여 자체 애플리케이션의 프로세스 정보를 검색할 수도 있다.     
특히 프로세스 전역 변수에서 프로세스에 할당된 환경 변수 목록(process.env 사용) 또는 실행 시 애플리케이션에 전달된 명령줄 인수(process.argv 사용)를 얻을 수 있다. 




## Running native code

네이티브 코드에 바인딩할 수 있는 사용자 영역 모듈을 생성할 수 있다. 이는 C/C++로 작성된 기존 구성요소 또는 새 구성요소를 재사용할 수 있게 해주므로 플랫폼에 엄청난 이점을 제공.    
Node.js는 N-API 인터페이스 덕분에 네이티브 모듈 구현을 공식적으로 지원. 우선, 기존의 방대한 양의 오픈 소스 라이브러리를 적은 노력으로 재사용할 수 있으며 가장 중요한 것은 회사에서 마이그레이션할 필요 없이 자체 C/C++ 레거시 코드를 재사용할 수 있다.    
또 다른 중요한 고려 사항은 하드웨어 드라이버 또는 하드웨어 포트(예: USB 또는 직렬)와의 통신과 같은 저수준 기능에 액세스하려면 기본 코드가 여전히 필요하다는 것: 실제로 Node.js는 네이티브 코드에 연결할 수 있는 기능 덕분에 사물 인터넷(IoT) 및 집에서 만든 로봇 공학의 세계에서 인기.     
마지막으로 V8이 JavaScript를 실행하는 데 매우 빠르지만 네이티브 코드를 실행하는 것과 비교하여 여전히 지불해야 하는 성능 저하

또한 오늘날 대부분의 JavaScript 가상 머신 (VM) (및 Node.js)은 JavaScript 이외의 언어 (예 : C ++ 또는 Rust)를 컴파일 할 수있는 저수준 명령 형식 인 WebAssembly (Wasm)를 지원. JavaScript VM이 "이해할 수 있는" 형식으로 변환.


